#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\begin_preamble
\usepackage{chngcntr}
\counterwithin*{section}{part}
\end_preamble
\use_default_options true
\begin_modules
todonotes
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command biber
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex
\cite_engine_type authoryear
\biblio_style plain
\biblatex_bibstyle ieee
\biblatex_citestyle ieee
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Literature Review - Cloud Services
\end_layout

\begin_layout Section
Hypertext Transfer Protocol (HTTP)
\end_layout

\begin_layout Standard
The core of the backend services in the context of this project is an HTTP
 (Hypertext Transfer Protocol) server.
 When running, a server is available at a hostname (http://google.com) which
 can be queried over the internet.
 HTTP servers are ubiquitous on the internet and most internet communications
 from retrieving websites to using web connected mobile apps and streaming
 video takes place between a client and an HTTP server.
 An HTTP server can be run locally on a PC but requires proper hosting in
 order to allow communications over the public internet.
 
\end_layout

\begin_layout Standard
Apart from their direct use by the user in websites and video streaming,
 HTTP can also be used to form APIs (Application Programming Interface)
 where text is instead sent back and forth to represent actions in a service.
\end_layout

\begin_layout Standard
At a high level HTTP APIs typically act as a layer of logic between users
 and databases for data persistence.
\end_layout

\begin_layout Section
Development Language
\end_layout

\begin_layout Standard
There are many languages well suited to writing HTTP servers from well establish
ed ecosystems like PHP, Java and Ruby to newer environments such as Python
 and Javascript using Node.js.
 An understanding of the language combined with high speed of prototyping
 led Python to be chosen.
 
\end_layout

\begin_layout Standard
Libraries for creating HTTP applications in Python typically implement the
 Web Server Gateway Interface (WSGI), an interface for passing web requests
 from the web server which hosts the application to the application itself.
 This theoretically allows any WSGI server to run any application written
 using a WSGI framework.
\end_layout

\begin_layout Standard
Two of the most popular frameworks are Flask
\begin_inset CommandInset citation
LatexCommand cite
key "flask"
literal "false"

\end_inset

 and Django
\begin_inset CommandInset citation
LatexCommand cite
key "django"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Django has a strong database abstraction layer and is 
\begin_inset Quotes eld
\end_inset

somewhat-opinionated
\begin_inset Quotes erd
\end_inset

 about the structure of web applications.
 Flask however has a more minimalist structure, functioning as a micro-framework
 that lightly wraps around both the Werkzeug library for a WSGI toolkit
 and Jinja for template engine support.
 It has no database layer or form validation, however it's un-opinionated
 structure and flexibility proves to be agile and very powerful.
 For these reasons Flask was chosen for implementing the WSGI interface.
 
\end_layout

\begin_layout Section
Cloud Computing Services
\end_layout

\begin_layout Standard
Google Cloud Platform
\begin_inset CommandInset citation
LatexCommand cite
key "gcp"
literal "false"

\end_inset

 (GCP) is a platform of cloud computing products from Google offering services
 from compute, storage and databases to networking, AI and IOT.
 Built upon the same infrastructure that hosts the public facing Google
 services, GCP is one of the largest and most feature rich platforms of
 it's type operating in the same space as Amazon Web Services and Microsoft's
 Azure platform.
\end_layout

\begin_layout Standard
With effective documentation and compelling free quotas combined with previous
 experience with the platform, GCP was used to provide all the hosting needs
 for the project.
 
\end_layout

\begin_layout Subsection
Compute Services
\end_layout

\begin_layout Standard
Deploying an HTTP server to the public internet can be done in various ways.
 One of the more established but manual approaches is to create a Linux
 virtual machine on which WSGI applications can be started using a WSGI
 server like Gunicorn.
 This presents one of the most manual methods requiring careful Linux administra
tion to create a secure public facing server, the growth of cloud computing
 platforms has removed the requirement for such overhead.
 
\end_layout

\begin_layout Subsubsection
Serverless Architecture
\end_layout

\begin_layout Standard
Serverless computing describes a new type of cloud service architecture
 that abstracts away much of the required administration, aiming to make
 the user experience feel 
\begin_inset Quotes eld
\end_inset

serverless
\begin_inset Quotes erd
\end_inset

.
 There are many different types of service using the architecture with the
 most popular being function-as-a-service or FaaS, the AWS and GCP products
 being Lambda functions and Cloud functions respectively.
 FaaS services allow users to write and deploy individual functions or methods
 of source code to be run by a trigger.
 
\end_layout

\begin_layout Standard
These triggers can include database state changes, asynchronous message
 queues or HTTP requests providing single functions with unique URLs to
 trigger them.
 HTTP triggers theoretically allow users to write entire APIs with endpoints
 as individual functions.
\end_layout

\begin_layout Subsubsection
PaaS
\end_layout

\begin_layout Standard
Platform as a service or PaaS is a similar architecture retaining many of
 the advantages of serverless products.
 It is a step towards the more manual approaches and implements the serverless
 ethos in a different way.
 To compare to FaaS which provides serverless hosting for individual methods
 of source code, PaaS can be seen as serverless hosting of entire WSGI applicati
ons when working in Python.
 In doing so the advantages of serverless hosting such as reduced configuration
 and high scalability are retained while allowing developers to create APIs
 in the industry standard WSGI format.
\end_layout

\begin_layout Standard
One of the main advantages of serverless (including PaaS) architecture is
 it's ability to horizontally scale on demand.
 Horizontal scaling describes a service's ability to handle concurrent traffic,
 typically scaling horizontally is achieved by running more instances of
 an application concurrently.
 This is in contrast to vertical scaling which instead describes a services
 ability to handle more traffic with the same resources, typically by making
 each instance faster.
\end_layout

\begin_layout Subsubsection
Google App Engine
\end_layout

\begin_layout Standard
Google App Engine (GAE) is a PaaS service by GCP providing application hosting
 for many different languages including Python.
 GAE provides many powerful features that either require complex configuration
 or are unfeasible with bare-metal or virtual machine based solutions.
\end_layout

\begin_layout Standard
For example GAE provides automatic horizontal scaling allowing the number
 of application instances to dynamically increase in response to increased
 traffic.
 The scope of the GCP infrastructure gives effectively unlimited horizontal
 scale to smaller services that would otherwise be unable to handle such
 demand.
\end_layout

\begin_layout Standard
GAE also makes using TLS security extremely easy.
 With a manual hosting set-up, TLS security can be included by attaching
 a certificate to the hosting web server, either purchased from a certificate
 authority such as Verisign or for free generated by Let's Encrypt.
 It is also advisable to include a rule within the web server in order to
 redirect unencrypted HTTP traffic on port 80 to encrypted HTTPS traffic
 on port 443.
\end_layout

\begin_layout Standard
App Engine includes TLS security with a Let's Encrypt certificate as standard
 and within the deployment configuration automatic redirects from HTTP to
 HTTPS can be added with one line.
 These two features can make development and deployment fast and secure.
\end_layout

\begin_layout Subsection
Database
\end_layout

\begin_layout Standard
GCP has many options for database services depending on the requirements.
 For both SQL and NoSQL, GCP has databases designed to operate at different
 scales and with different features.
 For example, Cloud SQL offers managed MySQL, PostgreSQL and SQL server
 instances with ultra low latency for smaller scale use but Cloud Spanner
 offers scalable SQL instances designed to be highly consistent at a global
 scale.
 
\end_layout

\begin_layout Standard
Equally, for NoSQL there are two main options.
 Cloud Bigtable offers global scale NoSQL database instances able to handle
 petabyte sized datasets designed for analytical big data workloads.
 Alternatively, Cloud Firestore is a new service from GCP under the Firebase
 brand banner.
\end_layout

\begin_layout Standard
Being marketed as the flagship NoSQL product, Firestore has key integrations
 with the rest of the GCP services, for example Cloud Functions can be triggered
 directly by changes within the database and Firebase provides authenticated
 access to the data from within mobile applications.
\end_layout

\begin_layout Standard
Firestore is also highly scalable and consistent as a result of it's serverless
 architecture.
\end_layout

\begin_layout Subsection
Mobile Notifications
\end_layout

\begin_layout Standard
Mobile notifications are a useful tool for providing instant messages and
 updates to a user having superseded the previously accepted methods of
 email and SMS messages.
 
\end_layout

\begin_layout Standard
While mobile applications can locally generate notifications, a more useful
 method of using notifications is for them to be generated and delivered
 by a cloud based service and transmitted over the internet.
 This allows changes in the service’s state such as changes in a user’s
 car battery level to be relayed to the user.
 
\end_layout

\begin_layout Standard
Due to the architecture of delivery and display when pushed over the internet,
 notification systems are usually part of the mobile operating system such
 as Firebase Cloud Messaging for Android and Apple Push Notification Service
 for iOS.
 Using Firebase Cloud Messaging messages can be sent to individual devices
 or groups of devices, the former being identified using a device specific
 key.
\end_layout

\begin_layout Subsection
Cloud Pub/Sub
\end_layout

\begin_layout Standard
Within a cloud system, the ability to orchestrate different aspects of the
 architecture can be facilitated by sending messages between services.
 This allows asynchronous updates and the spawning of tasks while maintaining
 inde- pendence of different parts of the architecture.
 A widely useful way to do this is by creating a communication channel within
 which messages can be published and subscribed to.
 Cloud Pub/Sub is a GCP service facilitating this form of communication.
 While it has many applications it is particularly useful for starting long
 running tasks triggered by HTTP requests or for background tasks within
 a service.
 
\end_layout

\begin_layout Standard
In order to fully utilise a serverless architecture as described above,
 FaaS Cloud Functions can be configured as subscribers to such messages,
 increasing the speed with which messages can be processed.
\end_layout

\begin_layout Subsection
Scheduling
\end_layout

\begin_layout Standard
When operating a system of larger scale, typically there will be tasks required
 to run repeatedly at predefined time intervals.
 Cloud Scheduler is a service within the Google Cloud Platform taking inspiratio
n from the Unix tool, Cron, allowing commands to be run in the background
 at flexibly defined times.
 Cloud Scheduler uses the same string format defining time schedules and
 has many different actions including Google App Engine URL endpoints and
 publishing messages to Pub/Sub message channels.
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Cloud Services
\end_layout

\begin_layout Standard
When designing a centralised commercial product with services available
 over the internet, the code to run those services cannot solely be run
 in individual phone apps or on IOT-esque pieces of hardware.
 The need for an authoritative store of information such as user details
 and service specific information (location and charge station details)
 requires a central instance of code to store information and make that
 data available when properly authorised.
\end_layout

\begin_layout Standard
The relationship between the code that the user interacts with directly
 (mobile app, charging unit) and that which centrally controls the service
 is described as the separation between the front-end and back-end of an
 application.
\end_layout

\begin_layout Standard
More precisely in the front-end/back-end model the back-end acts as the
 data access layer (DAL), while the front-end is the presentation layer
 for a service.
 
\end_layout

\begin_layout Section
Infrastructure Architecture
\end_layout

\begin_layout Standard
The architecture of cloud services utilised on GCP can be seen in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gcp-services"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename cloud-structure.png
	lyxscale 30
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Architecture of Google Cloud Platform services
\begin_inset CommandInset label
LatexCommand label
name "fig:gcp-services"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Google App Engine was used to host the Flask application in the standard
 environment which proves to be more than suitable for these requirements.
 This GAE application provides the public web hostname to interface with
 the mobile application and charging unit.
 
\end_layout

\begin_layout Standard
The need for a database was fulfilled by Firestore.
 Although a propriety SDK must be used to interface with the database, the
 library does have many benefits such as automatically authenticating database
 actions when code is running on deployed GCP services.
\end_layout

\begin_layout Standard
Cloud Scheduler is used to run utility tasks for the service at regular
 intervals, during development two were defined.
 Each task is encapsulated within a serverless Cloud Function which is triggered
 via subscription to separate Cloud Pub/Sub queues.
 Cloud Scheduler can then publish messages to these queues for consumption.
\end_layout

\begin_layout Standard
The access token refresh task is part of the authentication workflow, described
 further in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Authentication"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 In summary the confidential keys used to authenticate with the API should
 be refreshed periodically to reduce the value of any leaked data, this
 function performs that refresh action for all required users.
\end_layout

\begin_layout Standard
The reset queue tasks performs actions related to the semantics of the service.
 In the context of a workplace, the queue of users waiting for charging
 sessions should not necessarily roll over to the next day.
 Electric vehicle owners will typically charge their cars overnight leaving
 charging at work to function as a top up for the return commute.
 As a result, if a user is not able to receive a session that day, it does
 not necessarily mean they would still want an available session the next
 day.
 To allow this, locations can be configured to have the queue of users reset
 at midnight.
\end_layout

\begin_layout Standard
Each of the compute services being used, namely the GAE application and
 the serverless functions can be configured to use the centralised logging
 provided by GCP allowing intuitive log review.
\end_layout

\begin_layout Standard
Finally the Firebase SDK is used in order to deliver mobile notifications
 to users.
\end_layout

\begin_layout Section
Data Model
\end_layout

\begin_layout Standard
In designing the data model for this project objects were defined for users
 and the charging structure, a UML diagram for the architecture can be seen
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:class-diagram"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename class diagram.png
	lyxscale 30
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Class diagram for data model
\begin_inset CommandInset label
LatexCommand label
name "fig:class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
User
\end_layout

\begin_layout Standard
Users have associated usernames and passwords for identification and authenticat
ion.
 Usernames are the primary key differentiating objects and are case insensitive.
 Passwords are salted and hashed using the Werkzeug security functionality,
 for more information see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Passwords"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Defining user types allowed the implementation of access controls between
 different use cases.
 End-users are classed as 'user' and have limited access to much of the
 resource types while 'admin' accounts are able to make every types of request,
 naturally this set of users would be heavily restricted.
 Service accounts are used by the charging units in order to make changes
 on behalf of the system.
 This includes changing the state of the charging structure throughout the
 life cycle of a charging session, end-users cannot make any changes of
 this sort.
\end_layout

\begin_layout Standard
The state of the user is defined by the life-cycle of a charging session
 as described in the associated enumerated type.
 Using Python properties, specific state changes for a user have associated
 actions, this is where mobile notifications are triggered in order to inform
 the user of changes in the charging state.
\end_layout

\begin_layout Standard
Users have an access token field and associated last updated time in order
 to secure the HTTP API, the authentication methods used are covered in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Authentication"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The score and it's associated time of last update are used by the queue
 system in order to determine priorities when selecting the next users for
 a session slot.
 The score is a function of time since it's last update and the users actions
 in that time using update_score(), the score algorithm is covered in section
 
\color red
[SECTION WHERE JACK TALKS ABOUT ALGORITHM]
\color inherit
.
\end_layout

\begin_layout Standard
Check_password() takes a clear-text password string as input and returns
 a boolean value determining whether it is the same as the stored password.
\end_layout

\begin_layout Subsection
Charging Structure
\end_layout

\begin_layout Standard
The layout for charging architecture defines two object modelling physical
 structure and a session object.
 A Location defines a physical location at which are found charging stations.
 An office building with electric vehicle parking spaces would be a Location
 as would be a multi-storey car park.
 Functionally it is any group of charging spots.
\end_layout

\begin_layout Standard
A Charger is an individual charging station which will have an associated
 charging unit to relay session information.
 
\end_layout

\begin_layout Standard
A Session defines a discrete charging window completed by a user.
 It begins when the queue starts a session for a user who is informed as
 such.
 The user begins charging their car and upon completion is notified that
 they can remove their car.
 When a user unplugs the car the session ends and ticks the location's queue
 to select the next user.
\end_layout

\begin_layout Subsubsection
Location
\end_layout

\begin_layout Standard
A Location has a location_id to act as the primary key, they are case insensitiv
e.
 A location has a list of contained chargers and a list of users representing
 the queue waiting to charge.
 The tick_queue() function updates the score for each user in the queue
 and selects the lowest scoring to receive the next session if available.
 The queue is ticked both when a user is added to the queue and when a session
 ends to ensure the time is used effectively.
\end_layout

\begin_layout Subsubsection
Charger
\end_layout

\begin_layout Standard
A Charger's associated charger_id differentiates chargers of a location,
 they are unique to that location's namespace.
 The active session field is for the integer session_id of the currently
 running session if one is available.
 A null value indicates no session is running.
 The state field functions similarly to the same for the User object and
 defines the charger's position within the life cycle of a session.
\end_layout

\begin_layout Subsubsection
Session
\end_layout

\begin_layout Standard
Sessions are retained after their end for logging purposes, as such integer
 session IDs were selected in order to allow easier retrieval of new IDs.
 To do so the maximum value of all available IDs is incremented.
 Similarly to the charger key, session IDs are unique within their charger's
 namespace, this allows a single session to be identified by a fully qualified
 ID, separated by colons for example,
\end_layout

\begin_layout Quote
location1:charger1:5
\end_layout

\begin_layout Standard
Due to the use of IDs in request URLs and the fully qualified ID, colons,
 spaces and forward slashes are illegal characters for all three IDs.
 Sessions have date-time objects for both their start and end time and a
 reference to the User object who owns the session.
\end_layout

\begin_layout Section
Flask Server
\end_layout

\begin_layout Standard
Flask
\begin_inset CommandInset citation
LatexCommand cite
key "flask"
literal "false"

\end_inset

 is a lean Python web framework that provides flexibility and extensibility
 for web server development.
 The framework is used by instantiating a Flask application and registering
 routes with the app object.
\end_layout

\begin_layout Standard
Routes are registered using a function decorator provided by the application
 defining that method with a URL string pattern to match requests.
 The return value of the method is passed back to the HTTP requester as
 the response.
 This decorator takes both the intended route string pattern and the available
 HTTP methods as parameters.
\end_layout

\begin_layout Subsection
RESTful Services
\end_layout

\begin_layout Standard
When designing a web server it is worth considering REST architecture.
 REST or Representational State Transfer is a structure and ethos for designing
 web services that defines the semantics of what each URL means.
 Each URL is treated as an identifier for a resource it describes, making
 requests with different HTTP methods at this URL represents different actions
 to be taken on the object that URL identifies.
 The most common methods are GET, POST, PUT and DELETE.
\end_layout

\begin_layout Standard
GET is typically used as a read only method who's result is a text serialization
 of the object.
\end_layout

\begin_layout Standard
The POST method is used to create an object while PUT is used to replace
 the object.
 For this API PUT is used to replace individual fields of some objects making
 the definition of PUT closer to update.
\end_layout

\begin_layout Standard
DELETE is for deleting the object the URL denotes.
\end_layout

\begin_layout Standard
The aim of a RESTful web service is to make interacting with APIs consistent
 and intuitive both as a whole and when comparing different APIs.
 It is similar to a design pattern.
\end_layout

\begin_layout Standard
A diagram laying out the structure of the API URL routes can be seen in
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:api-route-map"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Blueprints
\end_layout

\begin_layout Standard
A useful tool for encapsulating discrete parts of a Flask API that should
 still be part of a single application is to use blueprints.
\end_layout

\begin_layout Standard
Blueprints group a set of routes allowing them to be mounted on a Flask
 application object together.
 Blueprints have routes registered in a similar fashion as the Flask application
, blueprints are then individually hung off of a prefix URL string by the
 application following instantiation.
\end_layout

\begin_layout Standard
Blueprints were used to separate routes for authentication, users and the
 charging structure in order to closely follow the data model, a visualisation
 of the final URL route map can be seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:api-route-map"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename api-map.png
	lyxscale 30
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisation of API endpoints with example fully qualified route
\begin_inset CommandInset label
LatexCommand label
name "fig:api-route-map"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Security
\end_layout

\begin_layout Standard
When operating a cloud-based commercial service arguably the most important
 aspect of it's design is that of security, breaches increasingly occur
 in large public companies allowing unauthorized access to customer's private
 information.
 
\end_layout

\begin_layout Standard
Fortunately, using a serverless architecture abstracts away much of the
 required boilerplate security administration such as managing complex firewall
 setups and intrusion detection and prevention systems (IDS/IPS), instead
 much of this low-level security is provided by the infrastructure itself.
\end_layout

\begin_layout Standard
The three main areas of this service requiring considerations from a security
 perspective are those of access controls, password handling and authentication.
 Access controls have been discussed above in the data model and layout
 of the HTTP API, it involves considering which users should be able to
 conduct what actions and what the implications of such access are.
 For example ensuring that only system owned accounts, admin accounts and
 the user who owns a session can manipulate it.
\end_layout

\begin_layout Subsection
Passwords
\begin_inset CommandInset label
LatexCommand label
name "subsec:Passwords"

\end_inset


\end_layout

\begin_layout Standard
Passwords should never be stored at rest in the cleartext form they are
 provided by users as any breaches of the database will expose sensitive
 user information.
 The impact of such a breach would not only cover this service but could
 prove devastating for users who use the same password across websites (however
 unadvisable that is), this proves to be valuable attack vector for bad
 actors.
\end_layout

\begin_layout Standard
To secure passwords they should undergo obfuscation processes such as salting
 and hashing.
 Hashing is a one-way function that takes a variable length string and produces
 a reproducible fixed length output, the same input string always provides
 the same output string.
 Importantly for password storage is the one way characteristic of the function,
 this means the hashed password cannot be inversely 
\begin_inset Quotes eld
\end_inset

un-hashed
\begin_inset Quotes erd
\end_inset

 back into the clear text string, even with knowledge as to what type of
 hashing was used.
 Cracking hashed passwords must instead be done with large tables of cleartext
 passwords and the associated precomputed hashes, this is known as a rainbow
 table attack.
 In order to protect against brute force attacks of this fashion, salts
 are additionally used.
 A salt is a random string of data that is appended to the user password
 before hashing and then stored with it.
 This reduces the effectiveness of a rainbow table attack as rainbow tables
 cannot practically be pre-calculated for input passwords when mangled by
 a random string in this way.
 For this implementation passwords are salted using a 8 character long salt
 before being hashed using the pbkdf2:sha256 algorithm.
\end_layout

\begin_layout Subsection
Authentication
\begin_inset CommandInset label
LatexCommand label
name "sec:Authentication"

\end_inset


\end_layout

\begin_layout Standard
Authentication is a crucial concern when designing web services.
 Access controls and other security measures are important facets of a system
 however they are useless if weak authentication allows them to be circumvented.
 There are many ways to secure a HTTP API that range in security and complexity,
 finding a balance for the context of the service is important.
 
\end_layout

\begin_layout Standard
Authentication describes the methods by which a user interacting with the
 API proves they are who they say they are.
 This is separate to the process of authorization which describes the process
 of proving that a user is able to do what they are trying to do.
 This difference is relevant when considering the intricacies of more complex
 security architectures however for these purposes both are done at the
 same time.
 
\end_layout

\begin_layout Standard
Most methods of authentication eventually authenticate each request using
 a HTTP header with the “Autho- rization” key of key-value pairs.
 The value of this header prescribes which method is being used.
 
\end_layout

\begin_layout Standard
During development basic authentication was used, this involves sending
 the username and password for the requesting user in the header of each
 request.
 This however requires the client to keep unprotected forms of the user
 credentials to be ready for inclusion in each request and must be used
 in conjunction with HTTPS to protect them from interception.
 For release a more secure form of authentication was used, bearer tokens.
\end_layout

\begin_layout Subsubsection
Bearer Token
\end_layout

\begin_layout Standard
A bearer token delegates the authentication authority from the user credentials
 themselves to a separate piece of secret information.
 In doing so, the need to repeatably share user passwords or the derivatives
 of is removed.
 This additional piece of information is a string of characters typically
 referred to as a key or token, it is provided with each request in the
 authorization header in the form
\end_layout

\begin_layout Quote
Bearer 
\emph on
<token>
\emph default
 
\end_layout

\begin_layout Standard
Bearer tokens in one form or another are the most common form of authorisation
 and authentication for web based APIs with standards such as OAuth (2.0)
 and JSON web tokens (JWT) being well regarded technologies in this space.
 OAuth describes an architecture for API authorization however while being
 a proven structure, the system is fairly complex and has an emphasis on
 allowing third party services delegated access to user information, something
 that wouldn’t be required for a service that expects only first party access.
 
\end_layout

\begin_layout Standard
This service uses a simpler implementation of bearer tokens with each user
 having a unique and randomly generated key stored with their user information.
 Tokens for accounts representing physical people are refreshed on a weekly
 basis, in doing so any compromised key has it’s value reduced as a result
 of it’s limited life time.
 Keys are not rotated for service accounts as the charging units are expected
 to run without user interaction.
 While users can log back into the app when their token expires, having
 charger unit keys expire in this way would require a workflow to supply
 new keys.
 
\end_layout

\begin_layout Standard
A more advanced system for refreshing charging unit keys could be based
 on a system of public key certificates similar to the way that web servers
 and websites prove their identity when using TLS, however this would require
 further investigation and discussion.
\end_layout

\begin_layout Section
Pricing
\end_layout

\begin_layout Standard
An important aspect of using a third-party hosting platform for all the
 required services is the prices for each service, both currently and when
 anticipating future growth.
 When looking back to figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gcp-services"
plural "false"
caps "false"
noprefix "false"

\end_inset

 each of the listed services have free tiers and prices following these
 quotas.
 Using estimations of possible system loads and the Google Cloud Platform
 pricing calculator
\begin_inset CommandInset citation
LatexCommand cite
key "gcp-pricing"
literal "false"

\end_inset

 an estimation of running costs can be obtained.
\end_layout

\begin_layout Standard
Firestore database allows 1GB of storage for free, a limit that with the
 scope of service required here would not be easily reached.
 It also allows 50,000 reads, 20,000 writes and 20,000 deletes a day.
\end_layout

\begin_layout Standard
The serverless Cloud Functions allow 2 million invocations a month for free
 with 400,000 GB-seconds memory, 200,000 GHz-seconds of compute time.
 Being used as a utility function for updating user access tokens means
 that these quotas would likely not be reached.
\end_layout

\begin_layout Standard
The service that is most likely to be used beyond it's free quotas is that
 of the App Engine.
 The App Engine provides 28 instance hours a day, while the service would
 not likely be used during the night busy times of day could see more simultaneo
us traffic to the service and require more running instances.
\end_layout

\begin_layout Standard
As a result, the price can be seen to be extremely reasonable for smaller
 services and the pay-as-you-go nature of invoicing is a significant advantage
 of the serverless technology used.
\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
An example JSON output from GETting location information can be seen in
 appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Results"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The Flask server proved extremely flexible in designing and implementing
 the required URL routes.
 The un-opinionated nature with respect to the handling of database connections
 was a strength when Firestore requires a proprietary SDK to be used, a
 simple database layer was written to match much of what would be achieved
 with a traditional Object-Relation Mapping (ORM).
 Worth noting however is that this was not as fast as industry standard
 libraries such as SQL-alchemy could provide, reading and writing to the
 database were the slowest aspects of the program and could definitely be
 optimised further.
 This architecture was achieved while remaining within the free quotas for
 all services making the development process free.
\end_layout

\begin_layout Section
Future Work
\end_layout

\begin_layout Standard
The back-end has room for development, future work could develop both the
 infrastructure and the source code itself.
 The infrastructure could be extended by increasing the utilisation of serverles
s functions and by considering the AI and IOT products provided by the platform.
 
\end_layout

\begin_layout Standard
The source code has more room for improvement, specifically the database
 layer could be optimised as it is currently the bottleneck for typical
 use.
 Retrieving a session, for example, involves first retrieving its parent
 charger and location which slows down processing.
\end_layout

\begin_layout Standard
Additionally the authentication scheme could be developed.
 While the bearer tokens as implemented are suitable, more complex systems
 have significant advantages.
 Specifically the use of JWTs would decrease processing time and provide
 more authentication information from a debugging and security perspective.
\end_layout

\begin_layout Section
Summary and Future Work
\end_layout

\begin_layout Standard
An array of cloud computing services have been orchestrated into a system
 functioning as the back-end for the scheduling project.
\end_layout

\begin_layout Standard
An HTTP server provides the public gateway to data contained within a database.
 At each point services built with modern architectures provided by the
 serverless philosophy have been used effectively to keep the system simple
 and the cost free.
 
\end_layout

\begin_layout Standard
The security of the architecture has also been considered, both in the context
 of those aspects abstracted away through the infrastructure choices and
 those which are part of the service itself.
\end_layout

\begin_layout Standard
Costs for running the service were shown to be free for small scale deployment
 and reasonably priced if usage were to increase, the services most likely
 to begin costing money were laid out.
\end_layout

\begin_layout Standard
Finally the space for development is presented, highlighting the investigations
 that could be made both into the infrastructure and the source code itself.
\end_layout

\begin_layout Standard
Despite these areas the final product successfully fulfils the specifications
 for cloud data storage in a stable and self-descriptive manner.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Discussion and Conclusions
\end_layout

\begin_layout Section
Discussions
\end_layout

\begin_layout Subsection
Environmental Impacts
\end_layout

\begin_layout Standard
While ostensibly being a response to the future of mobility grand challenge,
 the subject of the project being electric vehicles has obvious links with
 the environment and as such the wider environmental effects should be considere
d.
 While it is important to consider the direct sustainability, as has been
 done earlier, it is also worth investigating how the service encourages
 through it’s existence and use.
 
\end_layout

\begin_layout Standard
Initially it could be considered that the wider use of a vehicle charge
 management system would be positive.
 This would come as a result of the incentive provided by being able to
 charge a user’s car while at locations such as a workplace with limited
 spaces.
 As a result, the members of the workplace could be more likely to use electric
 vehicles over the alternative and the use of fossil fuelled cars would
 decrease.
 
\end_layout

\begin_layout Standard
However the service is designed to allow as much car charging as possible
 throughout the day.
 When a user’s car is full they are required to move it so another user
 can make use of the charging unit.
 This is as opposed to when a car charging space without such a management
 system is used, the user would probably not move the car throughout the
 day and so when the car has finished charging, the draw of power will stop.
 
\end_layout

\begin_layout Standard
Almost ironically the use of such an environmentally-minded service could
 actually increase the amount of power being used.
 At a time when the majority of power generated in the UK still comes from
 fossil fuels the overall effect could be negative.
 It is worth defining, then, the point of such a service and how it responds
 to the grand challenge it aims to solve.
\end_layout

\begin_layout Subsection
The Future of Mobility Grand Challenge
\end_layout

\begin_layout Standard
The scheduling service is intended to incentivise the use of electric vehicles
 by making it easier to charge them at a time where EVs are still, to an
 extent, in an immature state.
 As the amount of energy generated through renewables increases, the weight
 of the aforementioned negative impact is reduced while the energy sources
 of the assumed larger population of electric vehicles are made more sustainable.
 To directly respond to the grand challenge, this service aims to improve
 the future of mobility by easing the adoption of a new form of travel in
 electric vehicles.
 
\end_layout

\begin_layout Standard
The main drawbacks of EVs in comparison to their traditional fossil fuel
 counterparts are the frequency with which the battery must be charged,
 the length of time it takes to charge the battery and the availability
 of battery charging infrastructure.
 This service aims to allow the most efficient use of limited charging infrastru
cture such that EV owners can reduce the effects of these disadvantages
 and further encourage this emerging technology.
 While the above could demonstrate a larger draw of electricity at a time
 where this is still predominantly unsustainable, it ultimately promotes
 the adoption of a technology that will benefit from better sourced electricity
 in the future.
\end_layout

\begin_layout Subsection
User Behaviour
\end_layout

\begin_layout Standard
Another aspect of the service worth considering is the way in which bad
 faith interaction is reacted to and punished by the service.
 This negative behaviour would include actions such as delaying the start
 of a charging session when a user is selected and leaving a full car in
 the charging spot following the completion of a session.
 
\end_layout

\begin_layout Standard
The aim of a user’s score is to punish bad actors by reducing their ability
 to get further sessions, this leaves the service to be utilised by users
 more willing to properly engage with the service’s environment.
 
\end_layout

\begin_layout Standard
The user’s score, however, only affects a user within the context of the
 service.
 When considering the reasons for such “bad” interactions in a workplace
 environment many would be justifiable.
 
\end_layout

\begin_layout Standard
Overrunning meetings or time sensitive work are both common and when considering
 how the service is ultimately a utility for the company owning the charging
 spots, few if any would prioritise the interactions with the car charging
 structure over the work being completed by the employee for that company.
 
\end_layout

\begin_layout Standard
This highlights both how reliant the service is on users engaging in good
 faith to facilitate smooth operation and how the service could be susceptible
 to abuse.
\end_layout

\begin_layout Subsection
Group Work
\end_layout

\begin_layout Standard
Development of the three aspects of the service - the hardware unit, mobile
 application and cloud services were, in general, developed separately with
 a process of integration and final testing to assemble the final product.
 
\end_layout

\begin_layout Standard
This, in combination with a group structure that loosely divided between
 the software and hardware for the most frequent communication led to some
 integration issues that, with hindsight, could have benefited from a more
 collaborative approach or project management style.
 Each of the three aspects, however, did achieve their individual aims and
 provided the best components with which to complete the integrations.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
As part of this project a service has been designed and implemented allowing
 the dynamic scheduling of electric vehicle charging time.
 In doing so, the shared use of limited spaces with charging units can be
 systematically managed and used more efficiently than the alternative.
 
\end_layout

\begin_layout Standard
Integrating the hardware unit with the native J1772 protocol of the existing
 charging infrastructure allows intuitive sessions to be defined by the
 subject vehicle as opposed to predefined time windows, further improving
 the efficacy of the service.
 
\end_layout

\begin_layout Standard
The use of industry leading cloud platforms allowed a back-end service to
 be created that is highly available, can scale automatically with demand
 and could naturally operate at a global scale were it required.
 
\end_layout

\begin_layout Standard
The Android mobile application provides a natural user interface for that
 back-end while the use of mobile notifications makes the entire experience
 responsive.
 Discussion’s above highlight the relevance of this work to the grand challenge
 it aims to contribute to whilst also demonstrating the limitations of the
 design.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "references"
options "bibtotoc"

\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Results
\begin_inset CommandInset label
LatexCommand label
name "sec:Results"

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename example-output.png
	lyxscale 30
	width 70col%

\end_inset


\end_layout

\end_body
\end_document
